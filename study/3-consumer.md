# Consumer
<br><br>

## 1. 컨슈머의 주요 옵션
#### 올드 컨슈머
  - 주키퍼를 사용
  - 컨슈머의 오프셋을 **주키퍼의 z노드**에 저장
#### 뉴 컨슈머
  - 주키퍼를 사용하지 않음
  - 컨슈머의 오프셋을 주키퍼가 아닌 **카프카의 토픽**에 저장
  - (대부분 뉴 컨슈머를 사용하고 있음)

<br>

### 옵션
* #### bootstrap.servers
  - 카프카 클러스터에 처음 연결을 하기 위한 호스트와 포트 정보로 구성된 리스트 정보
  - 포맷: `호스트명:포트, 호스트명:포트, ...`
  - 전체 카프카 리스트가 아닌 호스트 하나만 입력해도 동작하지만, 해당 호스트에 장애가 발생하면 접속이 불가능해지므로 권장되지 않음

* #### fetch.min.bytes
  - 한 번에 가져올 수 있는 최소 데이터 사이즈
  - 만약 지정한 사이즈보다 작은 경우, 요청에 응답하지 않고 데이터가 누적될 때까지 기다림

* #### group.id
  - 컨슈머가 속한 컨슈머 그룹을 식별하는 식별자 (중요)

* #### enable.auto.commit
  - 백그라운드로 주기적으로 오프셋을 커밋

* #### auto.offset.reset
  - 카프카에서 초기 오프셋이 없거나 현재오프셋이 더이상 존재하지 않는 경우에 할 동작
  - `earliest`: 가장 초기의 오프셋값으로 설정
  - `latest`: 가장 마지막의 오프셋값으로 설정
  - `none`: 이전 오프셋값을 찾지 못하면 에러를 나타냄

* #### fetch.max.bytes
  - 한 번에 가져올 수 있는 최대 데이터 사이즈

* #### request.timeout.ms
  - 요청에 대해 응답을 기다리는 최대 시간

* #### session.timeout.ms
  - 컨슈머가 브로커사이의 세션 타임 아웃 시간
  - 브로커가 컨슈머가 살아있는 것으로 판단하는 시간 (default=10sec)
  - 컨슈머가 그룹 코디네이터에서 하트비트를 보내지 않고 session.timeout.ms이 지나면 해당 컨슈머는 종료되거나 장애가 발생한 것으로 판단 ▶️ 컨슈머그룹이 rebalance를 시도함
  - 즉 컨슈머가 하트비트 없이 얼마나 오랫동안 있을 수 있는지를 제어
  - heartbeat.interval.ms와 밀접한 관련

* #### heartbeat.interval.ms
  - 그룹 코디네이터에게 얼마나 자주 KafkaConsumer poll() 메소드로 하트비트를 보낼 것인지 조정
  - session.timeout.ms보다 낮아야 함 (일반적으로 1/3정도로 설정, default=3sec)

* #### max.poll.records
  - 단일 호출 poll()에 대한 최대 레코드 수를 조정
  - 이 옵션을 통해 애플리케이션이 폴링 루프에서 데이터 양을 조절할 수 있음

* #### max.poll.interval.ms
  - 컨슈머가 살아있는지를 체크하기 위해 하트비트를 주기적으로 보낼 때, 컨슈머가 하트비트만 보내고 실제로 메시지를 가져가지 않는 경우가 있을 수 있음
  - 이런 경우 컨슈머가 무한정 해당 파티션을 점유할 수 없도록 주기적으로 poll을 호출하지 않으면 장애라고 판단하고 컨슈머 그룹에서 제외
  - 그 후 다른 컨슈머가 해당 파티션에서 메시지를 가져갈 수 있게 함

* #### auto.commit.interval.ms
  - 주기적으로 오프셋을 커밋하는 시간

* #### fetch.max.wait.ms
  - fetch.min.bytes에 의해 설정된 데이터보다 적은 경우 요청에 응답을 기다리는 최대 시간

<br><br><br>

## 2. 컨슈머로 메시지 가져오기
### 2-1) 콘솔
카프카 설치 경로에서
```
./bin/kafka-console-consumer.sh --bootstrap-server [호스트명]:[포트], [호스트명]:[포트], ... --topic [토픽이름] --from-beginning
```

- `--bootstrap-server`: 뒤에 카프카 호스트 정보를 입력
- `--topic`: 뒤에 가져올 토픽의 이름을 입력
- `--from-beginning`: 토픽의 처음부터 메시지를 가져오게 하는 옵션

### 2-2) 프로그래밍 언어
참고: https://github.com/jinnyy/study-kafka/tree/master/practice

<br><br><br>

## 3. 파티션과 메시지 순서
카프카 컨슈머에서의 메시지 순서는 `동일한 파티션 내`에서는 프로듀서가 `생성한 순서와 동일`하게 처리하지만, 

`파티션과 파티션 사이`에서는 `순서를 보장하지 않는다`.

<br><br><br>

## 4. 컨슈머 그룹
일반적으로 컨슈머는 카프카 토픽에서 메시지를 읽어오는 역할을 함.
컨슈머 그룹은 하나의 토픽에 여러 컨슈머 그룹이 동시에 접속해 메시지를 가져올 수 있음.




<br><br><br><br>

## References
* https://kafka.apache.org/documentation/#consumerconfigs
* "카프카, 대용량 처리의 최강자", 고승범, 책만, 2018

<br>
