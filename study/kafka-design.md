# Kafka Design


<br><br>

## 1. 특징

### 분산 시스템
#### 장점
* 단일 시스템보다 높은 성능
* 여러 노드가 있으므로 다른 노드 장애 시 대처에 용이
* 시스템 확장 용이

<br>

### 페이지 캐시
처리량을 높이기 위해 OS의 페이지 캐시 이용
> **페이지 캐시**: 디스크 접근을 줄이기 위해 사용한 페이지를 저장해둔 후 다시 요청이 일어나면 캐시에서 읽어옴

<br>

### 배치 전송 처리
작은 I/O를 묶어서 처리
> I/O가 일어날 때마다 네트워크 비용이 발생하므로 I/O를 줄이면 오버헤드를 줄일 수 있다.

<br><br>


## 2. 카프카 데이터 모델

### 토픽
- 데이터를 구분하기 위한 단위
- 토픽별로 메시지를 저장
- 249자 미만
- 영문, 숫자, '.', '_', '-' 조합

<br>

### 파티션
- 토픽을 분할한 것

#### 토픽을 나누는 이유
- 한 파티션에서 모든 메시지를 처리하도록 하면 앞의 메시지가 처리될 때까지 뒤의 메시지들은 줄서서 기다려야 하기 때문
- 뒤에 줄서지 않아도 처리되게 하려면? → 줄을 하나 더 만들면 된다!
- **주의**: 빠른 전송을 위해서는 토픽의 파티션과 프로듀서의 수를 함께 늘려야 한다.

하지만 항상 파티션 수를 늘리는 것이 답은 아니다. 다음과 같은 부작용이 발생가능하기 때문:
- 파일 핸들러의 낭비
- 장애 복구 시간 증가

결론: 목표 처리량에 맞게 파티션 수를 정하자

<br>

### 오프셋과 메시지 순서
* #### 오프셋
  - 각 파티션마다 메시지가 저장되는 위치
  - 유일하고 순차적으로 증가하는 숫자 (64비트 정수)
* #### 메시지 순서
  - 한 파티션 안에서는 오프셋 순서대로만 consume

<br><br>


## 3. 카프카의 고가용성과 리플리케이션

### 리플리케이션 팩터와 리더, 팔로워의 역할
* #### 리플리케이션 팩터
	* default는 1
	* 카프카 설정 파일에서 변경 가능 (config/server.properties)
	* 토픽을 이루는 파티션을 리플리케이션

* #### 리더와 팔로워
  * 리더: 모든 데이터의 읽기 쓰기에 대한 요청에 응답하면서 데이터를 저장해나감
  * 팔로워: 리더를 주기적으로 확인하며 자신에게 없는 데이터를 리더로부터 가져옴

  * 하지만 리더가 다운되는 경우 팔로워 중에서 새로운 리더를 선발해야 하는데, 팔로워들의 데이터가 리더의 데이터와 일치하지 않을 수 있다는 문제가 있다.
    * 해결:  `ISR`이라는 개념을 도입
      * ISR: 현재 replicate되고 있는 리플리케이션 그룹
      * ISR에 속해 있는 구성원만이 리더가 될 수 있음


<br><br><br>

## Reference
"카프카, 대용량 처리의 최강자", 고승범, 책만, 2018
